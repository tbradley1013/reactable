---
title: "Examples"
output:
  html_document:
    toc: true
    toc_float:
      smooth_scroll: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(reactable)
```

## Basic Usage
To create a data table, use `reactable()` on a data frame or matrix.
The table will be sortable and paginated by default:
```{r}
library(reactable)

reactable(iris)
```

### Column definitions
Columns can be customized by providing a named list of column definitions
created by `colDef()` to `columns`:
```{r}
reactable(iris[1:5, ], columns = list(
  Sepal.Length = colDef(name = "Sepal Length"),
  Sepal.Width = colDef(name = "Sepal Width"),
  Species = colDef(align = "center")
))
```

For convenience, you can also specify a default `colDef()` to use for all
columns in `defaultColDef`:
```{r}
reactable(
  iris[1:5, ],
  defaultColDef = colDef(
    header = function(value) gsub(".", " ", value, fixed = TRUE),
    cell = function(value) format(value, nsmall = 1),
    align = "center",
    minWidth = 70,
    headerStyle = list(background = "#f7f7f8")
  ),
  columns = list(
    Species = colDef(minWidth = 140)  # overrides the default
  ),
  bordered = TRUE,
  highlight = TRUE
)
```


## Sorting
Tables are sortable by default. You can sort on a column by clicking on its
header, or sort on multiple columns by holding the shift key while sorting.

### Default sort order
Tables are sorted in ascending order first by default. To customize the sort order,
set `defaultSortOrder` on a table or column to either `"asc"` (ascending) or
`"desc"` (descending):
```{r}
reactable(
  iris[48:52, ],
  defaultSortOrder = "desc",
  columns = list(
    Species = colDef(defaultSortOrder = "asc")
  )
)
```

### Default sorted columns
You can pre-sort columns by specifying a vector of column names in `defaultSorted`:
```{r}
reactable(iris[48:52, ], defaultSorted = c("Species", "Petal.Length"))
```

You can also provide a named list to customize the sort orders:
```{r}
reactable(iris[48:52, ], defaultSorted = list(Species = "asc", Petal.Length = "desc"))
```

### Sort missing values last
You can ignore missing values when sorting by setting `sortNALast` on a column:
```{r}
reactable(
  data.frame(
    n = c(1, 2, 3, -Inf, Inf),
    x = c(2, 3, 1, NA, NaN),
    y = c("aa", "cc", "bb", NA, NA)
  ),
  defaultColDef = colDef(sortNALast = TRUE),
  defaultSorted = "x"
)
```

### No sorting
You can disable sorting by setting `sortable` to `FALSE` on the table or column.
When only some columns are sortable, it can be helpful to indicate sortable
columns using `showSortable`:
```{r}
reactable(
  iris[1:5, ],
  sortable = FALSE,
  showSortable = TRUE,
  columns = list(
    Petal.Width = colDef(sortable = TRUE),
    Petal.Length = colDef(sortable = TRUE)
  )
)
```

### Hide sort icons
You can hide sort icons by setting `showSortIcon` to `FALSE`. This may be
useful if want to use a
[custom sort indicator](cookbook/cookbook.html#custom-sort-indicators).
```{r}
reactable(iris[1:5, ], showSortIcon = FALSE)
```


## Filtering
You can make columns filterable using `filterable`:
```{r}
data <- MASS::Cars93[1:20, c("Manufacturer", "Model", "Type", "AirBags", "Price")]

reactable(data, filterable = TRUE, minRows = 10)
```

To make specific columns filterable (or not), set `filterable` in the column definition:
```{r}
reactable(data, filterable = TRUE, columns = list(
  Price = colDef(filterable = FALSE)
))
```


## Searching
You can make the entire table searchable using `searchable`:
```{r}
data <- MASS::Cars93[1:20, c("Manufacturer", "Model", "Type", "AirBags", "Price")]

reactable(data, searchable = TRUE, minRows = 10)
```


## Pagination
You can change the default page size by configuring `defaultPageSize`:
```{r}
reactable(iris[1:6, ], defaultPageSize = 4)
```

You can also set the minimum rows per page using `minRows`. This may be
useful when rows don't completely fill the page, or if the table has filtering:
```{r}
reactable(iris[1:6, ], defaultPageSize = 4, minRows = 4, searchable = TRUE)
```

### Page size options
You can show a dropdown of page sizes for users to choose from using `showPageSizeOptions`.
The page size options can be customized through `pageSizeOptions`:
```{r}
reactable(iris[1:12, ], showPageSizeOptions = TRUE, pageSizeOptions = c(4, 8, 12), defaultPageSize = 4)
```

### Alternative pagination types
You can use an alternative pagination type by setting `paginationType` to:

- `"jump"` to show a page jump
- `"simple"` to show previous/next buttons only

#### Page jump
```{r}
reactable(iris[1:50, ], paginationType = "jump", defaultPageSize = 4)
```

#### Simple
```{r}
reactable(iris[1:50, ], paginationType = "simple", defaultPageSize = 4)
```

### Hide page info
You can hide page info by setting `showPageInfo` to `FALSE`:
```{r}
reactable(iris[1:12, ], showPageInfo = FALSE, defaultPageSize = 4)

reactable(iris[1:12, ], showPageInfo = FALSE, showPageSizeOptions = TRUE, defaultPageSize = 4)
```

### Always show pagination
By default, pagination is hidden if the table only has one page. To always show
pagination, set `showPagination` to `TRUE`. This may be useful if you want to
show page info:

```{r}
reactable(iris[1:5, ], showPagination = TRUE)
```

### No pagination
Tables are paged by default, but you can disable pagination by setting `pagination` to `FALSE`:
```{r}
reactable(iris[1:20, ], pagination = FALSE, highlight = TRUE, height = 250)
```


## Grouping and Aggregation
You can group rows in a table by specifying one or more columns in `groupBy`:
```{r}
data <- MASS::Cars93[10:22, c("Manufacturer", "Model", "Type", "Price", "MPG.city")]

reactable(data, groupBy = "Manufacturer")
```

When rows are grouped, you can aggregate data in a column using an `aggregate` function:
```{r}
data <- MASS::Cars93[14:38, c("Type", "Price", "MPG.city", "DriveTrain", "Man.trans.avail")]

reactable(data, groupBy = "Type", columns = list(
  Price = colDef(aggregate = "max"),
  MPG.city = colDef(aggregate = "mean", format = colFormat(digits = 1)),
  DriveTrain = colDef(aggregate = "unique"),
  Man.trans.avail = colDef(aggregate = "frequency")
))
```

You can use one of the built-in aggregate functions:
```r
colDef(aggregate = "sum")        # Sum of numbers
colDef(aggregate = "mean")       # Mean of numbers
colDef(aggregate = "max")        # Max of numbers
colDef(aggregate = "min")        # Min of numbers
colDef(aggregate = "count")      # Count of values
colDef(aggregate = "unique")     # Comma-separated list of unique values
colDef(aggregate = "frequency")  # Comma-separated counts of unique values
```

Or a custom aggregate function in JavaScript:
```r
colDef(
  aggregate = JS("
    function(values, rows) {
      // input:
      //  - values: an array of all values in the group
      //  - rows: an array of row info objects for all rows in the group
      //
      // output:
      //  - an aggregated value, e.g. a comma-separated list
      return values.join(', ')
    }
  ")
)
```

### Multiple groups
```{r}
data <- data.frame(
  State = state.name,
  Region = state.region,
  Division = state.division,
  Area = state.area
)

reactable(
  data,
  groupBy = c("Region", "Division"),
  columns = list(
    Division = colDef(aggregate = "unique"),
    Area = colDef(aggregate = "sum", format = colFormat(separators = TRUE))
  ),
  bordered = TRUE
)
```


## Column Formatting
You can format data in a column by providing `colFormat()` options to `format`:
```{r}
data <- data.frame(
  price_USD = c(123456.56, 132, 5650.12),
  price_INR = c(350, 23208.552, 1773156.4),
  temp = c(22, NA, 31),
  percent = c(0.9525556, 0.5, 0.112),
  date = as.Date(c("2019-01-02", "2019-03-15", "2019-09-22"))
)

reactable(data, columns = list(
  price_USD = colDef(format = colFormat(prefix = "$", separators = TRUE, digits = 2)),
  price_INR = colDef(format = colFormat(currency = "INR", separators = TRUE, locales = "hi-IN")),
  temp = colDef(format = colFormat(suffix = " °C")),
  percent = colDef(format = colFormat(percent = TRUE, digits = 1)),
  date = colDef(format = colFormat(date = TRUE, locales = "en-GB"))
))
```

### Formatting aggregated cells
Column formatters apply to both standard and aggregated cells by default. If you
want to format aggregated cells separately, provide a named list of `cell` and
`aggregated` options:
```{r, eval=FALSE}
colDef(
  format = list(
    cell = colFormat(...),       # Standard cells
    aggregated = colFormat(...)  # Aggregated cells
  )
)
```

For example, only the aggregated `States` are formatted here:
```{r}
data <- data.frame(
  States = state.name,
  Region = state.region,
  Area = state.area
)

reactable(data, groupBy = "Region", columns = list(
  States = colDef(
    aggregate = "count",
    format = list(
      aggregated = colFormat(suffix = " states")
    )
  ),
  Area = colDef(
    aggregate = "sum",
    format = colFormat(suffix = " mi²", separators = TRUE)
  )
))
```

### Date Formatting
```{r}
datetimes <- as.POSIXct(c("2019-01-02 3:22:15", "2019-03-15 09:15:55", "2019-09-22 14:20:00"))
data <- data.frame(
  datetime = datetimes,
  date = datetimes,
  time = datetimes,
  time_24h = datetimes,
  datetime_pt_BR = datetimes
)

reactable(data, columns = list(
  datetime = colDef(format = colFormat(datetime = TRUE)),
  date = colDef(format = colFormat(date = TRUE)),
  time = colDef(format = colFormat(time = TRUE)),
  time_24h = colDef(format = colFormat(time = TRUE, hour12 = FALSE)),
  datetime_pt_BR = colDef(format = colFormat(datetime = TRUE, locales = "pt-BR"))
))
```

### Currency Formatting
```{r}
data <- data.frame(
  USD = c(12.12, 2141.213, 0.42, 1.55, 34414),
  EUR = c(10.68, 1884.27, 0.37, 1.36, 30284.32),
  INR = c(861.07, 152122.48, 29.84, 110, 2444942.63),
  JPY = c(1280, 226144, 44.36, 164, 3634634.61),
  MAD = c(115.78, 20453.94, 4.01, 15, 328739.73)
)

reactable(data, columns = list(
  USD = colDef(
    format = colFormat(currency = "USD", separators = TRUE, locales = "en-US")
  ),
  EUR = colDef(
    format = colFormat(currency = "EUR", separators = TRUE, locales = "de-DE")
  ),
  INR = colDef(
    format = colFormat(currency = "INR", separators = TRUE, locales = "hi-IN")
  ),
  JPY = colDef(
    format = colFormat(currency = "JPY", separators = TRUE, locales = "ja-JP")
  ),
  MAD = colDef(
    format = colFormat(currency = "MAD", separators = TRUE, locales = "ar-MA")
  )
))
```

### Displaying missing values
Missing values are ignored by formatters and shown as empty cells by default.
You can customize their display text by setting `na` on a column:
```{r}
reactable(
  data.frame(
    n = c(1, 2, NA, 4, 5),
    x = c(55, 27, NA, NaN, 19),
    y = c(1, NA, 0.25, 0.55, NA)
  ),
  columns = list(
    x = colDef(na = "–", format = colFormat(prefix = "$")),
    y = colDef(na = "NA", format = colFormat(percent = TRUE))
  )
)
```

### Custom Data Formatting
If none of the built-in formatters apply to your data, you can use a
[custom cell renderer](#cell-rendering) instead.


## Custom Rendering
You can customize how data is displayed using an R or JavaScript function
that returns custom content. R render functions support
[Shiny HTML tags](https://shiny.rstudio.com/articles/tag-glossary.html) (or
[`htmltools`](https://mastering-shiny.org/advanced-ui.html#generating-html)) and
[`htmlwidgets`](https://www.htmlwidgets.org/),
while JavaScript render functions allow for more dynamic behavior.

See [Custom Rendering](custom-rendering.html) for details on how to
use render functions, and the [Demo Cookbook](cookbook/cookbook.html)
for even more examples of custom rendering.

### Cell rendering

#### R render function
```{r}
data <- MASS::Cars93[1:5, c("Manufacturer", "Model", "Type", "AirBags", "Price")]

reactable(data, columns = list(
  Model = colDef(cell = function(value, index) {
    # Render as a link
    url <- sprintf("https://wikipedia.org/wiki/%s_%s", data[index, "Manufacturer"], value)
    htmltools::tags$a(href = url, target = "_blank", as.character(value))
  }),
  AirBags = colDef(cell = function(value) {
    # Render as ✘ or ✓
    if (value == "None") "\u2718" else "\u2713"
  }),
  Price = colDef(cell = function(value) {
    # Render as currency
    paste0("$", format(value * 1000, big.mark = ","))
  })
))
```

#### JavaScript render function
```{r}
data <- MASS::Cars93[1:5, c("Manufacturer", "Model", "Type", "AirBags", "Price")]

reactable(data, columns = list(
  Model = colDef(html = TRUE, cell = JS("
    function(cellInfo) {
      // Render as a link
      var url = 'https://wikipedia.org/wiki/' + cellInfo.row.Manufacturer + '_' + cellInfo.value
      return '<a href=\"' + url + '\" target=\"_blank\">' + cellInfo.value + '</a>'
    }
  ")),
  AirBags = colDef(cell = JS("
    function(cellInfo) {
      // Render as ✘ or ✓ 
      return cellInfo.value === 'None' ? '\u2718' : '\u2713'
    }
  ")),
  Price = colDef(cell = JS("
    function(cellInfo) {
      // Render as currency
      return '$' + (cellInfo.value * 1000).toLocaleString()
    }
  "))
))
```

#### Embedding HTML widgets
```{r message=FALSE}
library(dplyr)
library(sparkline)

data <- chickwts %>%
  group_by(feed) %>%
  summarise(weight = list(weight)) %>%
  mutate(boxplot = NA, sparkline = NA)

reactable(data, columns = list(
  weight = colDef(cell = function(values) {
    sparkline(values, type = "bar", chartRangeMin = 0, chartRangeMax = max(chickwts$weight))
  }),
  boxplot = colDef(cell = function(value, index) {
    sparkline(data$weight[[index]], type = "box")
  }),
  sparkline = colDef(cell = function(value, index) {
    sparkline(data$weight[[index]])
  })
))
```

### Aggregated cell rendering
```{r, message=FALSE}
library(dplyr)

set.seed(10)

data <- sample_n(tail(MASS::Cars93, 9), 30, replace = TRUE) %>%
  select(Manufacturer, Model, Type, Sales = Price)

reactable(
  data,
  groupBy = "Manufacturer",
  searchable = TRUE,
  columns = list(
    Model = colDef(aggregate = "unique"),
    Type = colDef(aggregated = JS("
      function(cellInfo) {
        // Get comma-separated list of unique values in visible rows
        var values = cellInfo.subRows.map(function(row) { return row.Type })
        var unique = values.reduce(function(obj, v) { obj[v] = true; return obj }, {})
        return Object.keys(unique).join(', ')
      }
    ")),
    Sales = colDef(aggregated = JS("
      function(cellInfo) {
        // Calculate sum of all values in visible rows
        var values = cellInfo.subRows.map(function(row) { return row.Sales })
        var total = values.reduce(function(a, b) { return a + b }, 0)
        return '$' + total.toFixed(1)
      }
    "))
  )
)
```

### Header rendering
```{r}
library(htmltools)

reactable(
  iris[1:5, ],
  defaultColDef = colDef(header = function(value) {
    units <- div(style = "color: #999", "cm")
    div(title = value, value, units)
  }),
  columns = list(
    Petal.Width = colDef(name = "Petal Width", html = TRUE, align = "left", header = JS("
      function(colInfo) {
        return colInfo.column.name + '<div style=\"color: #999\">cm</div>'
      }
    ")),
    Species = colDef(header = function(value) {
      tags$a(href = "https://wikipedia.org/wiki/List_of_Iris_species", title = "Iris species", value)
    })
  )
)
```


## Footers
You can add column footers by specifying content to render in `footer`.

`footer` can also be an R or JavaScript render function — see
[Custom Rendering](custom-rendering.html) for details on how to
use render functions.

#### R render function
```{r, message=FALSE}
library(dplyr)
library(htmltools)

data <- MASS::Cars93[18:47, ] %>%
  select(Manufacturer, Model, Type, Sales = Price)

reactable(
  data,
  defaultPageSize = 5,
  columns = list(
    Manufacturer = colDef(footer = "Total"),
    Sales = colDef(footer = function(values) sprintf("$%.2f", sum(values)))
  ),
  defaultColDef = colDef(footerStyle = list(fontWeight = "bold"))
)
```

#### JavaScript render function
```{r}
reactable(
  data,
  searchable = TRUE,
  defaultPageSize = 5,
  minRows = 5,
  columns = list(
    Manufacturer = colDef(footer = "Total"),
    Sales = colDef(
      footer = JS("function(colInfo) {
        var values = colInfo.data.map(function(row) { return row[colInfo.column.id] })
        var total = values.reduce(function(a, b) { return a + b }, 0)
        return '$' + total.toFixed(2)
      }")
    )
  ),
  defaultColDef = colDef(footerStyle = list(fontWeight = "bold"))
)
```

#### Embedding HTML widgets {#embedding-html-widgets-footers}
```{r}
library(sparkline)

reactable(
  iris[1:20, ],
  defaultPageSize = 5,
  bordered = TRUE,
  defaultColDef = colDef(footer = function(values) {
    if (!is.numeric(values)) return()
    sparkline(values, type = "box", width = 100, height = 30)
  })
)
```


## Expandable Row Details
You can make rows expandable with additional content through `details`, which
takes an R or JavaScript render function. See [Custom Rendering](custom-rendering.html)
for details on how to use render functions.

```{r}
reactable(iris[1:5, ], details = function(index) {
  htmltools::div(
    "Details for row: ", index,
    htmltools::tags$pre(paste(capture.output(iris[index, ]), collapse = "\n"))
  )
})
```

The details column can be customized by providing a `colDef()` instead:
```{r}
reactable(iris[1:5, ], details = colDef(
  name = "More",
  details = JS("function(rowInfo) {
    return 'Details for row: ' + rowInfo.index +
      '<pre>' + JSON.stringify(rowInfo, null, 2) + '</pre>'
  }"),
  html = TRUE,
  width = 60
))
```

### Nested tables
With R render functions, you can render HTML tags, HTML widgets, and even nested tables:
```{r}
data <- unique(CO2[, c("Plant", "Type")])

reactable(data, details = function(index) {
  plant_data <- CO2[CO2$Plant == data$Plant[index], ]
  htmltools::div(style = "padding: 16px",
    reactable(plant_data, outlined = TRUE)
  )
})
```

### Conditional row details
R render functions support conditional rendering. If a render function
returns `NULL`, the row won't be expandable:
```{r}
reactable(iris[1:5, ], details = function(index) {
  if (index %in% c(3, 5)) {
    reactable(data.frame(x = c(1, 2, 3), y = c("a", "b", "c")), fullWidth = FALSE)
  }
})
```

### Multiple row details
You can add `details` to individual columns, and even show multiple details for a row:
```{r}
reactable(iris[1:5, ],
  details = function(index) {
    if (index %in% c(3, 5)) {
      reactable(data.frame(x = c(1, 2, 3), y = c("a", "b", "c")), fullWidth = FALSE)
    }
  },
  columns = list(
    Petal.Length = colDef(details = function(index) {
      paste("Petal.Length: ", iris[index, "Petal.Length"])
    }),
    Sepal.Length = colDef(format = colFormat(digits = 1), details = JS("
      function(rowInfo) {
        return 'Sepal.Length: ' + rowInfo.row['Sepal.Length']
      }
    "))
  )
)
```

### Default expanded rows

> **New in v0.1.0.9000**

You can expand all rows by default by setting `defaultExpanded` to `TRUE`:
```{r}
reactable(
  iris[1:4, ],
  details = function(index) paste("Details for row:", index),
  defaultExpanded = TRUE
)
```


## Conditional Styling
You can conditionally style a table using functions that return inline styles
or CSS classes. Just like with custom rendering, style functions can either be
in R or JavaScript.

See [Conditional Styling](conditional-styling.html) for details on how to
use style functions, and the [Demo Cookbook](cookbook/cookbook.html)
for even more examples of conditional styling.

### Cell styling
```{r}
reactable(sleep[1:6, ], columns = list(
  extra = colDef(style = function(value) {
    if (value > 0) {
      color <- "#008000"
    } else if (value < 0) {
      color <- "#e00000"
    } else {
      color <- "#777"
    }
    list(color = color, fontWeight = "bold")
  })
))
```

```{r}
reactable(sleep[1:6, ], columns = list(
  extra = colDef(style = JS("
    function(rowInfo) {
      var value = rowInfo.row.extra
      if (value > 0) {
        var color = '#008000'
      } else if (value < 0) {
        var color = '#e00000'
      } else {
        var color = '#777'
      }
      return { color: color, fontWeight: 'bold' }
    }
  "))
))
```

### Row styling
```{r row_styling, eval=FALSE}
reactable(sleep[1:6, ], 
  rowStyle = function(index) {
    if (sleep[index, "extra"] < -1) {
      list(background = "rgba(0, 0, 0, 0.05)")
    }
  },
  rowClass = function(index) {
    if (sleep[index, "extra"] < -1) {
      "bold"
    }
  }
)
```

```{css}
.bold {
  font-weight: bold;
}
```

```{r ref.label="row_styling", echo=FALSE}
```

```{r}
reactable(sleep[1:6, ],
  rowStyle = JS("function(rowInfo) {
    if (rowInfo.row.extra < -1) {
      return { background: 'rgba(0, 0, 0, 0.05)' }
    }
  }"),
  rowClass = JS("function(rowInfo) {
    if (rowInfo.row.extra < -1) {
      return 'bold'
    }
  }")
)
```


## Table Styling

You can customize table styling using several options, which can all be combined:

### Highlight rows on hover

```{r}
reactable(iris[1:5, ], highlight = TRUE)
```

### Bordered

```{r}
reactable(iris[1:5, ], bordered = TRUE)
```

### Borderless

```{r}
reactable(iris[1:5, ], borderless = TRUE)
```

### Outlined

```{r}
reactable(iris[1:5, ], outlined = TRUE)
```

### Striped

```{r}
reactable(iris[1:5, ], striped = TRUE)
```

### Bordered + striped + highlighting

```{r}
reactable(iris[1:5, ], bordered = TRUE, striped = TRUE, highlight = TRUE)
```

### Outlined + borderless

```{r}
reactable(iris[1:5, ], outlined = TRUE, borderless = TRUE)
```

### Compact

```{r}
reactable(iris[1:5, ], compact = TRUE)
```

### No text wrapping
Long text is wrapped by default, but you can force text to fit on a single line
by setting `wrap` to `FALSE`:
```{r}
data <- aggregate(. ~ Species, iris, toString)

reactable(data, wrap = FALSE, resizable = TRUE)
```

### Fixed height + sticky header/footer
You can make tables scrollable by setting a fixed height or width.
Headers and footers are sticky by default, so they stay in place when scrolling:
```{r}
reactable(
  iris[1:20, ],
  height = 270,
  striped = TRUE,
  borderless = TRUE,
  defaultColDef = colDef(
    footer = function(values, name) htmltools::div(name, style = list(fontWeight = 600))
  )
)
```

### No full width
Tables are full width by default, but you can shrink the table to fit its
contents by setting `fullWidth` to `FALSE`:
```{r}
reactable(iris[1:5, ], fullWidth = FALSE, bordered = TRUE, defaultColDef = colDef(minWidth = 120))
```


## Column Groups
You can create column groups by passing a list of `colGroup()` definitions to `columnGroups`:
```{r}
reactable(
  iris[1:5, ],
  columns = list(
    Sepal.Length = colDef(name = "Length"),
    Sepal.Width = colDef(name = "Width"),
    Petal.Length = colDef(name = "Length"),
    Petal.Width = colDef(name = "Width")
  ),
  columnGroups = list(
    colGroup(name = "Sepal", columns = c("Sepal.Length", "Sepal.Width")),
    colGroup(name = "Petal", columns = c("Petal.Length", "Petal.Width"))
  )
)
```


## Column Resizing
You can make columns resizable using `resizable`:
```{r}
reactable(iris[1:5, ], resizable = TRUE, bordered = TRUE)
```


## Row Names
Row names are shown by default, if present. You can customize the row names column
using `.rownames` as the column name:
```{r}
reactable(USPersonalExpenditure, columns = list(
  .rownames = colDef(name = "Category", sortable = TRUE)
))
```

If row names haven't been set explicitly, you can force them to show by setting
`rownames` to `TRUE`:
```{r}
reactable(iris[1:5, ], rownames = TRUE)
```


## Cell Click Actions
You can add cell click actions using `onClick`, which accepts the following values:

- `"expand"` to expand the row
- `"select"` to select the row
- a JavaScript function for a custom action, e.g., sending the click event to Shiny

### Expand on click
```{r}
reactable(
  iris[48:52, ],
  groupBy = "Species",
  details = function(index) paste("Details for row:", index),
  onClick = "expand",
  # Give rows a pointer cursor to indicate that they're clickable
  rowStyle = list(cursor = "pointer")
)
```

### Select on click
```{r}
reactable(iris[1:5, ], selection = "multiple", onClick = "select")
```

### Custom action
```{r}
reactable(iris[1:5, ], onClick = JS("
  function(rowInfo, colInfo) {
    window.alert('clicked row ' + rowInfo.index + ', column ' + colInfo.id)

    // Send the click event to Shiny (note that the row indices start at 0 in JavaScript)
    if (window.Shiny) {
      Shiny.onInputChange('clicked', { column: colInfo.id, index: rowInfo.index + 1 })
    }
  }
"))
```


## Shiny
To use reactable in Shiny apps, use `renderReactable()` and `reactableOutput()`:
```{r, eval=FALSE}
library(shiny)
library(reactable)

ui <- fluidPage(
  titlePanel("reactable example"),
  reactableOutput("table")
)

server <- function(input, output, session) {
  output$table <- renderReactable({
    reactable(iris)
  })
}

shinyApp(ui, server)
```

### Row selection
You can enable row selection by setting `selection` to `"single"`
for single selection, or `"multiple"` for multiple selection.

To get the selected rows in Shiny, specify a Shiny input ID through
`selectionId`. The selected rows are given as a vector of row indices
(e.g. `c(1, 6, 4)`) or `NULL` if no rows are selected.

```{r, eval=FALSE}
library(shiny)
library(reactable)

ui <- fluidPage(
  titlePanel("row selection example"),
  reactableOutput("table"),
  verbatimTextOutput("selected")
)

server <- function(input, output, session) {
  output$table <- renderReactable({
    reactable(iris, selection = "multiple", selectionId = "selected", onClick = "select")
  })

  output$selected <- renderPrint({
    print(input$selected)
  })

  # Note: use ignoreNULL = FALSE to handle deselected rows with observeEvent
  observeEvent(input$selected, ignoreNULL = FALSE, {
    print(iris[input$selected, ])
  })
}

shinyApp(ui, server)
```

#### Default selected rows

> **New in v0.1.0.9000**

You can preselect rows by specifying a vector of row indices in `defaultSelected`:
```{r}
reactable(iris[1:4, ], selection = "multiple", defaultSelected = c(1, 3))
```

#### Style selected rows

> **New in v0.1.0.9000**

You can style selected rows using a `rowClass` or `rowStyle` JavaScript function:
```{r}
reactable(
  iris[1:4, ],
  selection = "multiple",
  defaultSelected = c(1, 3),
  rowClass = JS("function(rowInfo) {
    return rowInfo.selected ? 'selected' : ''
  }"),
  rowStyle = JS("function(rowInfo) {
    if (rowInfo.selected) {
      return { backgroundColor: '#eee', boxShadow: 'inset 2px 0 0 0 #ffa62d' }
    }
  }"),
  borderless = TRUE,
  onClick = "select"
)
```

### Update a reactable instance

> **New in v0.1.0.9000**

You can update the selected rows, expanded rows, or current page using `updateReactable()`:
```{r, eval=FALSE}
library(shiny)
library(reactable)

ui <- fluidPage(
  actionButton("select_btn", "Select rows"),
  actionButton("clear_btn", "Clear selection"),
  actionButton("expand_btn", "Expand rows"),
  actionButton("collapse_btn", "Collapse rows"),
  actionButton("page_btn", "Change page"),
  reactableOutput("table")
)

server <- function(input, output) {
  output$table <- renderReactable({
    reactable(
      iris,
      selection = "multiple",
      details = function(index) paste("Details for row:", index)
    )
  })

  observeEvent(input$select_btn, {
    # Select rows
    updateReactable("table", selected = c(1, 3, 5))
  })

  observeEvent(input$clear_btn, {
    # Clear row selection
    updateReactable("table", selected = NA)
  })

  observeEvent(input$expand_btn, {
    # Expand all rows
    updateReactable("table", expanded = TRUE)
  })

  observeEvent(input$collapse_btn, {
    # Collapse all rows
    updateReactable("table", expanded = FALSE)
  })

  observeEvent(input$page_btn, {
    # Change current page
    updateReactable("table", page = 3)
  })
}

shinyApp(ui, server)
```


```{css echo=FALSE}
/* rmarkdown html documents */
.main-container {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
}

.main-container blockquote {
  font-size: inherit;
}

/* pkgdown articles */
.contents {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
}

.contents blockquote {
  font-size: inherit;
}

.reactable {
  font-size: 14px;
}
```
